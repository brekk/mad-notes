[[02 - Writing functions, in the main|Previously]] we talked through the basics of running Madlib in a [[01 - Hello mad, mad world#REPL|REPL]] or your favorite [[02 - Writing functions, in the main#Defining functions|text editor]].

In this document we'll talk about:
- setting up an integrated development environment (IDE)
- the module segmentation Madlib uses

## Integrated Development Environment (IDE)
### Vim / Neovim

See [[03.1 - Developing Madlib in Neovim|this document]] to learn more about setting up a Madlib environment in Neovim.
### VS Code

See [[03.2 - Developing Madlib in VS Code|this document]] to learn more about setting up a Madlib environment in VS Code.

## Building a library

In [[02 - Writing functions, in the main|the previous guide]], we had this sample code:

```mad
import IO from "IO"

say :: String -> String -> String
say = (word, subject) => word ++ " " ++ subject

main = () => {
  pipe(
    say("hello"),
    IO.putLine
  )("world")
}
```

This was an all-in-one main file written in order to allow us to jump into Madlib development simply and quickly — here we're going to add a few wrinkles which allow us to segment our code into modular parts.

Firstly, let's set up a new codebase with [[madlib new]] — this will allow us to set up a few files automatically. For the porpoises of this guide, let's call this "the-garden". Start this process off by running `madlib new the-garden`:

```sh
> madlib new the-garden
package name [the-garden]:
package version [0.0.1]:
Your project is ready, do 'cd the-garden'
```

As the program suggests, now change directories to `the-garden`: `cd the-garden`

## Getting the lay of the land

Here's a breakdown of the files in our new garden plot:

```
the-garden
├── madlib.json
├── README.md
└── src
   └── Main.mad
```

***TODO: update the autogenerated README.md file, it should be better***

### madlib.json

If we take a look at the `madlib.json` file, we'll see a small surface area:

```json
{
  "name": "the-garden",
  "version": "0.0.1",
  "main": "src/Main.mad"
}
```

We can use this file to articulate upstream dependencies and a few other details, but we won't be going into that with any depth here.

### Source files

In the [[02 - Writing functions, in the main|previous guide]], we were just running things directly via `madlib run`. In this project, we're going to keep our source files in the `src` folder. This isn't strictly necessary but gives us some structure as we flesh out this library — by convention we've chosen this pattern for Madlib libraries.

Let's create a few files in `/src` and then we'll discuss them in depth further below

#### Main.mad

Since we used `madlib new`, the extant `Main.mad` file was automatically generated for us. You can go ahead and erase its contents and copy in this file:

```mad
import IO from "IO"

import Plant from "./Plant"



main = () => {
  banyan = Plant.makeSeed("Banyan", 1)
  pipe(
    IO.pTrace("seeded!"),
    Plant.grow,
    IO.pTrace("germination!"),
  )(banyan)
}
```
#### Plant.mad

Similarly, we should now create the `"./Plant"` file referenced in the `Main.mad` file.

```mad
export type GrowthStage
  = Seed
  | Germination
  | Roots
  | Shoots
  | Leaves
  | Mature
  | Flowering
  | Pollinated
  | Senescent
  | Dead

__grow :: GrowthStage -> GrowthStage
__grow = where {
  Seed =>
    Germination

  Germination =>
    Roots

  Roots =>
    Shoots

  Shoots =>
    Leaves

  Leaves =>
    Mature

  Mature =>
    Flowering

  Flowering =>
    Pollinated

  Pollinated =>
    Senescent

  Senescent =>
    Dead

  _ =>
    Dead
}

export type Plant = Plant(String, GrowthStage, Short)

grow :: Plant -> Plant
export grow = where {
  Plant(name, stage, id) =>
    Plant(name, __grow(stage), id)
}

makeSeed :: String -> Short -> Plant
export makeSeed = Plant($, Seed, $)
```

### Explanation

Ok, we've added a bunch of stuff here, let's walk through it and explain how it works.

```mad
make :: {} -> {} -> Short
export make = () => {
  count = 0
  return () => {
    count := count + 1
    return count
  }
}
```

This `make` function in the `Counter.mad` file allows us to represent a stateful value. Let's interrogate its type signature: `make :: {} -> {} -> Short`. If you recall from a [[01 - Hello mad, mad world|previous guide]], this is the Unit value, which is a singleton value. It represents the absence of types / parameters. If you recall from the previous guide, we had the binary function `say`, which took two Strings and returned a String. This `make` function is also a binary function, but it takes Unit for both of its first parameters — so effectively, this function takes nothing, twice, and returns a [[Numeric Types|Short]] number value.

If you'd like, we can import this within the [[01 - Hello mad, mad world#REPL|REPL]] to play with it (`madlib repl`):

```mad
> import Counter from "./src/Counter.mad"
> count = Counter.make()
> count()
1 :: Short
```
