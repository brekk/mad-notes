---
tags:
  - ide
  - development
  - library
  - pattern-matching
  - import
  - export
  - guide
---
[[02 - Writing functions, in the main|Previously]] we talked through the basics of running Madlib in a [[01 - Hello mad, mad world#REPL|REPL]] or your favorite [[02 - Writing functions, in the main#Defining functions|text editor]].

In this document we'll talk about:
- setting up an integrated development environment (IDE)
- the module segmentation Madlib uses

## Integrated Development Environment (IDE)

If you want to write Madlib code and have the best experience, currently the two editors we have the most support for are Neovim and VS Code. Please see one of the following documents for a better articulation of the setup process. If you have a different preferred editor and want to help improve our offerings, please get in touch!
### Vim / Neovim

See [[03.1 - Developing Madlib in Neovim|this document]] to learn more about setting up a Madlib environment in Neovim.
### VS Code

See [[03.2 - Developing Madlib in VS Code|this document]] to learn more about setting up a Madlib environment in VS Code.

## Building a library

In [[02 - Writing functions, in the main|the previous guide]], we had this sample code:

```mad
import IO from "IO"

say :: String -> String -> String
say = (word, subject) => word ++ " " ++ subject

main = () => {
  pipe(
    say("hello"),
    IO.putLine
  )("world")
}
```

This was an all-in-one main file written in order to allow us to jump into Madlib development simply and quickly — here we're going to add a few wrinkles which allow us to segment our code into modular parts.

## The new new

Firstly, let's set up a new codebase with [[madlib new]] — this will allow us to set up a few files automatically. For the porpoises of this guide, let's call this "mood-board". Start this process off by running `madlib new mood-board`:

```sh
> madlib new mood-board
package name [mood-board]:
package version [0.0.1]:
Your project is ready, do 'cd mood-board'
```

As the program suggests, now change directories to `mood-board`: `cd mood-board`

## Laying out our mood board

Here’s the directory structure that is automatically generated by `madlib new`:

```
mood-board
├── madlib.json
├── README.md
└── src
   └── Main.mad
```

### madlib.json

This file tells the compiler (and humans too!) a few important bits of information.

```json
{
  "name": "mood-board",
  "version": "0.0.1",
  "main": "src/Main.mad"
}
```

In this autogenerated file we're just seeing the `"name"`, current `"version"` and which file to use as the downstream `"main"` file (which is important if / when this library is used as a dependency in another Madlib library). We won't go into things further in this document, but we'll discuss this [[madlib.json|more later on]].

### README.md

This document is designed to be read by humans. As a result, we won't discuss it further here — but you should plan to edit this document to be helpful to other humans!

### src/Main.mad

The automatically generated `Main.mad` is a very simple file with a `main` function in it. Go ahead and open it in your IDE now. We're going to remove everything in it and replace it with the following:

```mad
import IO from "IO"
import type { Person } from "./Person"
import { mood, Sad, Happy } from "./Person"

main = () => {
  brekk = Person("Brekk", 36, Sad)
  pipe(
    mood,
    (m) => m == Happy,
    IO.trace("But are you happy?")
  )(brekk)
}
```

With this file in place, we're going to talk through the affordances (warnings / errors / help) that should be made available to you if you've set up your IDE properly. Then we'll add and update the `"./Person"` file being referenced in the imports so that we can make the language server happy.

Firstly, depending on how you've configured your editor, if you have auto-formatting on, you'll see that the formatter will change the ordering of the import statements and the ordering of the imports themselves. This is done to [[Low Friction|provide consistency]] and help prevent [bike-shedding](https://en.wikipedia.org/wiki/Law_of_triviality). You can read more about this specific behavior [[madlib format#Sort of important|here]].

With auto-formatting, you should now see these imports:

```
import type { Person } from "./Person"

import IO from "IO"

import { Happy, mood, Sad } from "./Person"
```

Since we haven't defined a `"./Person"` file, you should also see [[Errors#Import not found|an error]] on the first line: "Import not found".

Let's open a split / pane and start defining our Person file so we can rectify this issue.
### src/Person.mad

We'll start by defining this file incorrectly / incompletely so you can see how the language server feedback changes. If you are troubleshooting or want to jump ahead, the full file is available [here]().

```mad
type Person = Person(String, Short, Mood)
```

Here we've declared a type, `Person`, which has one constructor (also called `Person`!) — this declaration says that in order to create a `Person` we need to provide three arguments:
1. A [[String]] — we're gonna use this as the person's name
2. A [[Numeric Types#Short|Short]] — this is a number that we're gonna use as a loosely unique identifier
3. A Mood — this is a new type that we haven't defined yet.

## Some type of Mood

With this written, the compiler will indicate that it doesn't know about Mood and claim that it doesn't know about the [[Errors#Unknown type|Unknown type]] we've defined here. In order to solve this we need to define that Mood type:

```mad
type Mood = Happy | Sad | Indifferent
```

With this we've declared that a `Mood` is a new type, and that there are three constructors for that type, each of them nullary (so they don't take any parameters, they are just the thing itself), and right now a `Mood` can be one of `Happy` or `Sad` or `Indifferent`.

(You can add this before or after the `Person` definition, Madlib should pick it up either way.)

With this addition, now you should be seeing two warnings (well, more if you're eagle-eyed, but let's start with the ones on the `Person` type declaration):

1. [[Warnings|Unused type]]
2. [[Warnings|Unused constructor]]

Both of these can be addressed with the same solution, since we're not using this type in the file currently but (if you recall from what we wrote earlier) instead in `src/Main.mad`: we need to `export` the `Person`, and we also need to export the `Mood`:

```mad
export type Person = Person(String, Short, Mood)
export type Mood = Happy | Sad | Indifferent
```

Write this file and we'll swap back to `src/Main.mad` briefly.

You should see a [[Errors#Not exported|Not exported]] error now, pointing at `mood` on this line:

```mad
import { Happy, Sad, mood } from "./Person"
```

So let's go back to `src/Person.mad` and define a `mood` function. In order to query a `Person`'s `Mood`, we'll need some function to access that information.

## A moody function

Since `Person` is a container type, we can use the magic of [[Pattern Matching|pattern matching]] to access the internal `Mood` value of the `Person`:

```
mood :: Person -> Mood
export mood = where {
  Person(_, _, m) =>
    m
}
```

We've also used [[Pattern Matching#Wildcards|wildcards]] to tell the compiler that we don't care about the first two values that the Person has (specifically, the `String` / **name** and the `Short` / **id** values). Save this file with the new `mood` function exported.

Ok, we're in the home stretch!

Let's swap back to `src/Main.mad` — the language server should now be telling you about an [[Errors#Unbound variable|Unbound variable]], pointing at `Person` on this line:

```mad
brekk = Person("Brekk", 36, Sad)
```

Why is this mad at us? We already have this line:

```mad
import type { Person } from "./Person"
```

The reason is because we've defined a `type Person` but we've also defined a constructor `Person` which is the only constructor for that type.

So we need to update _this import declaration_ instead, adding `Person`:

```mad
import { Happy, Person, Sad, mood } from "./Person"
```

In a brief hypothetical, we could have defined things differently:

```mad
type Character = Person(String, Short, Mood) | Animal(String, Short, Mood)
```

In this new case, we'd `import type { Character }` and `import { Person, Animal }` instead.

There's one remaining warning, an [[Warnings#Unused import|Unused import]] — Madlib is now helpfully informing us that we're not even using the `Person` type, so we can actually remove this line:

```mad
import type { Person } from "./Person"
```

## Vibe check

Now you should be able to run `madlib run src/Main.mad` and see the text:

```sh
But are you happy? false
```

You can change this by changing the code, or you can change this by learning more about Madlib!
### Challenge:

In order to test our understanding and comprehension of what we've learned in this guide, here's a small challenge: 
### Solution:

See a possible solution to the challenge

## Summary
- Setting up an [[03 - The March of IDEs#Integrated Development Environment (IDE)|IDE]]
- Creating a [[03 - The March of IDEs#The new new|new Madlib project]] using `madlib new`
- Exploring [[03 - The March of IDEs#madlib.json|the]] [[03 - The March of IDEs#README.md|files]] [[03 - The March of IDEs#src/Main.mad|which]] are created by `madlib new`
- [[03 - The March of IDEs#src/Person.mad|Many common errors and warnings]] that Madlib may throw at you
- Defining a [[03 - The March of IDEs#Some type of Mood|custom type]]
- Using [[03 - The March of IDEs#A moody function|pattern matching]] to destructure a custom type
- Running a [[03 - The March of IDEs#Vibe check|main]] file which leverages a library